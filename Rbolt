library(Storm)
library(forecast)

storm = Storm$new()


storm$lambda = function(s)
{
    t = s$tuple
    s$ack(t)                                # acknowledge receipt of the tuple.
   # s$log(c("processing tuple=",t$id))      # log a message.
	
  t$output[1] = t$input[1]; #clinetname
  t$output[2] = t$input[3]; #timestamp
  t$output[3] = t$input[4]; #processlist

    
    limit.v = as.numeric(t$input[2]); #limit
    limit.p = 0.7
  
  cpuV = vector(mode="numeric",length=10);
  ramV = vector(mode="numeric",length=10);
  i = 0;
  while( i < 10){
    cpuV[i+1] = as.numeric(t$input[i*2+5]); #cpu1...
    ramV[i+1] = as.numeric(t$input[i*2+6]); #ram1...
     i = i+1;
   }   

        dataPred = ts(cpuV)
        fitPred = auto.arima(dataPred)
        point = data.frame(forecast(fitPred, h=1))$Point.Forecast
        se = sqrt(KalmanForecast(n.ahead = 1, fitPred$model)[[2]]*fitPred$sigma2)
        prob = 1-pnorm((limit.v-point)/se)
        warning = prob > limit.p
        
        t$output[4] = as.numeric(point);
        t$output[5] = as.numeric(se);
        t$output[6] = as.numeric(prob);
        t$output[7] = as.numeric(waring);

        dataPred = ts(ramV)
        fitPred = auto.arima(dataPred)
        point = data.frame(forecast(fitPred, h=1))$Point.Forecast
        se = sqrt(KalmanForecast(n.ahead = 1, fitPred$model)[[2]]*fitPred$sigma2)
        prob = 1-pnorm((limit.v-point)/se)
        warning = prob > limit.p
        
        t$output[8] = as.numeric(point);
        t$output[9] = as.numeric(se);
        t$output[10] = as.numeric(prob);
        t$output[11] = as.numeric(waring);



        s$emit(t)            # emit 1st tuple

}

# enter the main tuple-processing loop.
storm$run()
